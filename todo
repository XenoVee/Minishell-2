// Executor currently works with the following struct:

typedef struct s_commands
{
	char		*cmd;
	char		**args;
	bool		pipe;
	t_commands	*next;
	t_commands	*prev;
	t_data_fd	*fd_data;
}		t_commands;

// It is a linked list containing all the commands that are seperated by PIPES

	char		*cmd;
// contains the argument to be ran. because of how **args works, this is not neccesary. if we want to keep it reccomend having cmd = args[0] or removing
	char		**args;
// array that contains all the arguments to the command. Keep in mind that the first argument to a command is the command name itself
	bool		pipe;
// wether or not this command is being pipe. Probably not neccessary: If a command is being piped, s_commands->next should exist, if it is not being piped that shoul be NULL
	t_commands	*next;
	t_commands	*prev;
// next and previous commands in the linked list
	t_data_fd	*fd_data;
// the filedescriptor struct, containing information about the filedescriptors of the in/outfiles. it looks like this:

typedef struct s_data_fd
{
	char	*infile;
	char	*outfile;
	int		fd_in;
	int		fd_out;
	char	*delim_hd;
	bool	*quotes_hd;
}	t_data_fd;

	char	*infile;
// file path of the infile. Not needed by the executor if we open the infile before, only need the filedescriptor
	char	*outfile;
// file path of the outfile Not needed by the executor if we open the infile before, only need the filedescriptor
	int		fd_in;
// file descriptor of the infile. should be set to -1 if there is on infile
	int		fd_out;
// file descriptor of the outfile. should be set to -1 if there is on infile
	char	*delim_hd;
// Previous partner made this, executor does not use it (yet)
	bool	*quotes_hd;
// Previous partner made this, executor does not use it (yet)



// So our parser needs to take a line such as the following:
grep -o "\b[[:alpha:]]*\b" < words.txt | sed '/^$/d' | sort | uniq -c > output.txt ;
// And break it down into the following:

struct one
{
	cmd = "grep";
	args = {"grep", "-o", "\b[[:alpha:]]*\b"};
	pipe = TRUE;
	next = two;
	prev = NULL;
	fd_data = fd_struct;
};

struct two
{
	cmd = "sed";
	args = {"sed", "/^$/d"};
	pipe = TRUE;
	next = three;
	prev = one;
	fd_data = fd_struct;
};

struct three
{
	cmd = "sort";
	args = {"sort"};
	ipe = TRUE;
	next = four;
	prev = three;
	fd_data = fd_struct;
};

struct four
{
	cmd = "uniq";
	args = {"uniq", "-c"};
	pipe = FALSE;
	next = NULL;
	prev = three;
	fd_data = fd_struct;
};

// and the fd struct:
struct fd_struct
{
	infile = "words.txt";
	outfile = "output.txt";
	fd_in = open(infile);
	fd_out = open(outfile);
	delim_hd;
	quotes_hd;
};

/* Things to keep in mind: */

// Using single ('') and double ("") quotes has different behaviours when it comes to expanding variables.
// The executor currently does not handle expansion itself: its expectets the parser to do this. meaning that with double quotes:
export VAR=test;
echo "$VAR";
// the command struct should be as follows:
struct command
{
	cmd = "echo";
	args = {"echo", "test"};
...
}
// but with single quotes:
export VAR=test;
echo '$VAR';
// it should look like this
struct command
{
	cmd = "echo";
	args = {"echo", "$VAR"};
...
}


// the executor does not use the t_commands->cmd at all, because the first argument in t_commands->args NEEDS to be the same. Reccomend removing it


// I cant quite remember what the
	char	*delim_hd;
	bool	*quotes_hd;
// were used for, but the executor does not use it. reccomend removing it


// The current filedescriptor setup is not sufficient, as multiple in and outfiles are possible, which this does not support. A command chain can have only one infile:
// the following command as example:
grep "text" < infile.txt | rev | cut -c 2- < infile2.txt | sort
// In bash, the cut command will ignore any input from the pipe, as it takes it input from the infile 'file2.txt'
// we can NOT forgo running any of the commands before that command, however:

// one command chain can use multiple outfiles:
// the following command as example
grep "text" < infile.txt | rev > outfile1.txt | cut -c 2- < infile2.txt | sort > outfile2.txt;
// the rev command will put its output into the file 'outfile1.txt', and not into the pipe.
// the cut command will then take its input from the file 'file2.txt', instead of the pipe.
// this is a way to chain commands without using ';' or '&&'
// we should decide if we want to handle this the same way that bash does. If we do, each command will need its own in and outfile file descriptors

// another oddity with in and outfiles: multiple files on one simple command:
cat < infile1.txt < infile2.txt > outfile1.txt > outfile2.txt;
// only the last infile is used. All outfiles are used, however. outfile file descriptors may need to be stored in a list?


// the parser does NOT need to check if a command is valid/exists. The executor does this, and commands will handle faulty arguments themselves


// Even though the executor needs the env struct, this is only to be able to run commands like env and export, and pass the environment to the commands.
// it does NOT handle expansion itself! The env struct is a doubly linked list that I made a small library for: the cdl_list library. this one is specifically made to work with the env. 
// all functions needed to create and work with the struct should already be made
// the function to create the struct still need to be called in main/somewhere before execution, the executor does NOT create it.


// With the change to linux, the MakeFile is sure to need some work as well.